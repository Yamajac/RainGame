;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   RAINGAME - Yamajac, /u/Yamatjac, @Yamajac#3141, CharlotteConnolly@yamajac.com
;
;   The most fully featured game engine to ever exist in Rainmeter. 
;   (Though it's also the only public one, so maybe that's a little disingenuous :D)
;
;   Play prebuilt custom worlds from other users or build your own using the included
;   world builder(Soonâ„¢). Quests, monsters, inventories, you name it... eventually.
;
;  
;   TODO:
;       - Object interactions
;       - NPC Dialogue
;       - Inventory
;       - Quests
;       - Random Encounters
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; All the boring shit
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[Rainmeter]
Update = 16
DefaultUpdateDivider = -1
[Metadata]
Name        = Raingame
Author      = Yamajac - /u/Yamatjac
Information = A game engine written entirely in Rainmeter .ini files
Version     = Alpha

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Some more boring shit
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[Variables]
Game = ExampleGame
PlayerDirection = Down
ObjectLayers =

; ??
CURSEC = CURRENTSECTION



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Actually cool shit
; 
; Don't Repeat Yourself
; Save often used bang groups as variables so you can edit them all at once
; I forgot this was a thing earlier so I won't follow the DRY principle entirely
; But it's EXTREMELY useful for skins like this
; Unfortunately we can't do this for bangs with #CURRENTSECTION# in them :(
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; HandleMove Conditions + Bangs
HandleMoveOnUpdate    = [!UpdateMeasureGroup PlayerUpdate][!UpdateMeterGroup PlayerUpdate][!Redraw]
; DetectMove Conditions + Bangs
DetectMoveCondition   = ([#Tile[&[#*CURRENTSECTION*]]] = 0) || ([#Tile[&[#*CURRENTSECTION*]]] = 1)
DetectMoveCondition2  = [#Tile[&[#*CURRENTSECTION*]]] = 2
DetectMoveCondition3  = [#Tile[&[#*CURRENTSECTION*]]] = 3
DetectMoveTrueAction  = [!UpdateMeasureGroup PlayerMoved][!UpdateMeterGroup PlayerMoved]
DetectMoveFalseAction = 
DetectMoveTrueAction2 = [!UpdateMeasure Refresher]
DetectMoveTrueAction3 = [!UpdateMeasure HandleSwaps]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Game Functions - Player movement, collision detection, etc
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; "Save" function. Update this measure to save all the saveable data and reload the game
; Should probably separate the save and reload functions but I don't have a reason to yet
; and it won't be difficult at all if I ever do need to.
[Refresher]
Measure  = Calc
Group    = NoUpdate
Disabled = 1
DynamicVariables = 1
OnUpdateAction   = [!WriteKeyValue Variables PlayerX #PlayerX# "#@#Games/#Game#/#Game#.inc"][!WriteKeyValue Variables PlayerY #PlayerY# "#@#Games/#Game#/#Game#.inc"][!WriteKeyValue Variables CurrentScreen #CurrentScreen# "#@#Games/#Game#/#Game#.inc"][!Refresh]

; Swap tiles and apply an optional object layer
; Pass the tiletype with the data to the LayerSwap Variable and then update the measure
; For using this on an event other than a player colliding with an interactable tile, just build a 
; dummy tiletype and pass that tiletype to the function.
[HandleSwaps]
Measure  = String
String   = [#ObjectLayer[#LayerSwap]]
Group    = NoUpdate
Disabled = 1
DynamicVariables = 1
IfMatchMode      = 1
IfMatch          = >
IfMatchAction    = [!UpdateMeasureGroup ObjectLayerDeleter]
IfNotMatchAction = [!UpdateMeasure AddObjectLayer]
OnUpdateAction   = [!UpdateMeasureGroup Swap][!UpdateMeasureGroup ObjectLayers][!UpdateMeterGroup ObjectLayers][!Redraw] 
[GetObjectLayerToDelete]
Measure  = String
String   = [HandleSwaps]
Group    = NoUpdate | ObjectLayerDeleter
Disabled = 1
DynamicVariables = 1
Substitute       = ">" : ""
[DeleteObjectLayer]
Measure  = String
String   = #ObjectLayers#
Group    = NoUpdate | ObjectLayerDeleter
Disabled = 1
DynamicVariables = 1
Substitute       = "[GetObjectLayerToDelete]|" : ""
OnUpdateAction   = [!SetVariable ObjectLayers [#CURRENTSECTION#]]
[AddObjectLayer]
Measure  = String
String   = #ObjectLayers#
Group    = NoUpdate
Disabled = 1
DynamicVariables = 1
OnUpdateAction   = [!SetVariable ObjectLayers #ObjectLayers#[#ObjectLayer[#LayerSwap]]|]
[SwapFrom]
Measure  = String
String   = [#From[#LayerSwap]]
Group    = NoUpdate | Swap
Disabled = 1
MinValue = 0
DynamicVariables = 1
RegExpSubstitute = 1
Substitute       = ".{0,[SwapFrom:MinValue]}(.).*" : "\1"
[SwapTo]
Measure  = String
String   = [#To[#LayerSwap]]
Group    = NoUpdate | Swap
Disabled = 1
MinValue = 0
DynamicVariables = 1
RegExpSubstitute = 1
Substitute       = ".{0,[SwapTo:MinValue]}(.).*" : "\1"
[Swap]
Measure  = String
String   = #Collisions#
Group    = NoUpdate | Swap
Disabled = 1
DynamicVariables = 1
Substitute       = "[SwapFrom]":"[SwapTo]"
IfConditionMode  = 1
IfCondition      = [SwapFrom:MinValue] < 10
IfTrueAction     = [!SetVariable Collisions [#CURRENTSECTION#]][!SetOption SwapFrom MinValue ([SwapFrom:MinValue]+1)][!SetOption SwapTo MinValue ([SwapTo:MinValue]+1)][!UpdateMeasureGroup Swap]
IfFalseAction    = [!SetOption SwapFrom MinValue 0][!SetOption SwapTo MinValue 0]

; Sound engine
; On update plays the sound in SoundX where X is the measure's MinValue
[PlaySounds]
Measure  = String
Group    = NoUpdate | PlayerUpdate
Disabled = 1
String   = [#Sound[#PlaySound]]
DynamicVariables = 1
IfMatchMode      = 1
IfMatch          =  \[#*Sound[#PlaySound]*]
IfNotMatchAction = [!log "#@#Games/#Game#/Resources/Sounds/[#Sound[#PlaySound]].wav"][Play "#@#Games/#Game#/Resources/Sounds/[#Sound[#PlaySound]].wav"]

; Player movement functions
; Update the MoveUp, MoveLeft, MoveRight, MoveDown measure groups to try and move the
; player in that direction. Collisions are calculated using a collisions map in the
; screen. Updates measuregroup TileX where X is the tiletype the player tried 
; to move into, whether it was a success or not.
; Tiletype resolving to 2 will not call a callback function as it refreshes the skin
[HandleMoveUp]
Measure  = Calc
Formula  = #PlayerY# - 1
Group    = MoveUp | NoUpdate
Disabled = 1
DynamicVariables = 1
OnUpdateAction   = [!SetVariable PlayerDirection Up][!SetOption DetectMoveUp MinValue "([#CURRENTSECTION#] * #GameWidth# + #PlayerX#)"][!UpdateMeasure DetectMoveUp]#HandleMoveOnUpdate#
[DetectMoveUp]
Measure  = String
String   = #Collisions#
Group    = NoUpdate
Disabled = 1
DynamicVariables = 1
RegExpSubstitute = 1
Substitute       = ".{[DetectMoveUp:MinValue]}(.).*":"\1"
OnUpdateAction   = [!SetVariable PlaySound [#CURRENTSECTION#]]
IfConditionMode  = 1
IfCondition      = #DetectMoveCondition#
IfTrueAction     = [!SetVariable PlayerY [HandleMoveUp]][!UpdateMeasureGroup Tile[#CURRENTSECTION#]]#DetectMoveTrueAction#
IfFalseAction    = [!UpdateMeasureGroup Tile[#CURRENTSECTION#]]#DetectMoveFalseAction#
IfCondition2     = #DetectMoveCondition2#
IfTrueAction2    = [!SetVariable PlayerY [#Y[&[#CURRENTSECTION]]]][!SetVariable PlayerX [#X[&[#CURRENTSECTION]]]][!SetVariable CurrentScreen [#Screen[&[#CURRENTSECTION]]]]#DetectMoveTrueAction2#
IfCondition3     = #DetectMoveCondition3#
IfTrueAction3    = [!SetVariable LayerSwap [#CURRENTSECTION#]]#DetectMoveTrueAction3#

[HandleMoveLeft]
Measure  = Calc
Formula  = #PlayerX# - 1
Group    = MoveLeft | NoUpdate
Disabled = 1
DynamicVariables = 1
OnUpdateAction   = [!SetVariable PlayerDirection Left][!SetOption DetectMoveLeft MinValue "(#PlayerY# * #GameWidth# + [#CURRENTSECTION#])"][!UpdateMeasure DetectMoveLeft]#HandleMoveOnUpdate#
[DetectMoveLeft]
Measure  = String
String   = #Collisions#
Group    = NoUpdate
Disabled = 1
DynamicVariables = 1
RegExpSubstitute = 1
Substitute       = ".{[DetectMoveLeft:MinValue]}(.).*":"\1"
OnUpdateAction   = [!SetVariable PlaySound [#CURRENTSECTION#]]
IfConditionMode  = 1
IfCondition      = #DetectMoveCondition#
IfTrueAction     = [!SetVariable PlayerX [HandleMoveLeft]][!UpdateMeasureGroup Tile[#CURRENTSECTION#]]#DetectMoveTrueAction#
IfFalseAction    = [!UpdateMeasureGroup Tile[#CURRENTSECTION#]]#DetectMoveFalseAction#
IfCondition2     = #DetectMoveCondition2#
IfTrueAction2    = [!SetVariable PlayerY [#Y[&[#CURRENTSECTION]]]][!SetVariable PlayerX [#X[&[#CURRENTSECTION]]]][!SetVariable CurrentScreen [#Screen[&[#CURRENTSECTION]]]]#DetectMoveTrueAction2#
IfCondition3     = #DetectMoveCondition3#
IfTrueAction3    = [!SetVariable LayerSwap [#CURRENTSECTION#]]#DetectMoveTrueAction3#

[HandleMoveRight]
Measure  = Calc
Formula  = #PlayerX# + 1
Group    = MoveRight | NoUpdate
Disabled = 1
DynamicVariables = 1
OnUpdateAction   = [!SetVariable PlayerDirection Right][!SetOption DetectMoveRight MinValue "(#PlayerY# * #GameWidth# + [#CURRENTSECTION#])"][!UpdateMeasure DetectMoveRight]#HandleMoveOnUpdate#
[DetectMoveRight]
Measure  = String
String   = #Collisions#
Group    = NoUpdate
Disabled = 1
DynamicVariables = 1
RegExpSubstitute = 1
Substitute       = ".{[DetectMoveRight:MinValue]}(.).*":"\1"
OnUpdateAction   = [!SetVariable PlaySound [#CURRENTSECTION#]]
IfConditionMode  = 1
IfCondition      = #DetectMoveCondition#
IfTrueAction     = [!SetVariable PlayerX [HandleMoveRight]][!UpdateMeasureGroup Tile[#CURRENTSECTION#]]#DetectMoveTrueAction#
IfFalseAction    = [!UpdateMeasureGroup Tile[#CURRENTSECTION#]]#DetectMoveFalseAction#
IfCondition2     = #DetectMoveCondition2#
IfTrueAction2    = [!SetVariable PlayerY [#Y[&[#CURRENTSECTION]]]][!SetVariable PlayerX [#X[&[#CURRENTSECTION]]]][!SetVariable CurrentScreen [#Screen[&[#CURRENTSECTION]]]]#DetectMoveTrueAction2#
IfCondition3     = #DetectMoveCondition3#
IfTrueAction3    = [!SetVariable LayerSwap [#CURRENTSECTION#]]#DetectMoveTrueAction3#

[HandleMoveDown]
Measure  = Calc
Formula  = #PlayerY# + 1
Group    = MoveDown | NoUpdate
Disabled = 1
DynamicVariables = 1
OnUpdateAction   = [!SetVariable PlayerDirection Down][!SetOption DetectMoveDown MinValue "([#CURRENTSECTION#] * #GameWidth# + #PlayerX#)"][!UpdateMeasure DetectMoveDown]#HandleMoveOnUpdate#
[DetectMoveDown]
Measure  = String
String   = #Collisions#
Group    = NoUpdate
Disabled = 1
DynamicVariables = 1
RegExpSubstitute = 1
Substitute       = ".{[DetectMoveDown:MinValue]}(.).*":"\1"
OnUpdateAction   = [!SetVariable PlaySound [#CURRENTSECTION#]]
IfConditionMode  = 1
IfCondition      = #DetectMoveCondition#
IfTrueAction     = [!SetVariable PlayerY [HandleMoveDown]][!UpdateMeasureGroup Tile[#CURRENTSECTION#]]#DetectMoveTrueAction#
IfFalseAction    = [!UpdateMeasureGroup Tile[#CURRENTSECTION#]]#DetectMoveFalseAction#
IfCondition2     = #DetectMoveCondition2#
IfTrueAction2    = [!SetVariable PlayerY [#Y[&[#CURRENTSECTION]]]][!SetVariable PlayerX [#X[&[#CURRENTSECTION]]]][!SetVariable CurrentScreen [#Screen[&[#CURRENTSECTION]]]]#DetectMoveTrueAction2#
IfCondition3     = #DetectMoveCondition3#
IfTrueAction3    = [!SetVariable LayerSwap [#CURRENTSECTION#]]#DetectMoveTrueAction3#


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Pre-Init: Grab the current game and load the data into memory
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

[LoadGame]
@IncludeGame   = #@#Games/#Game#/#Game#.inc
@IncludeScreen = #@#Games/#Game#/Screens/#CurrentScreen#.inc

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Init: Draw the game screen and initialize game hooks/events
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

[GameArea]
Meter = Shape
Shape = Rectangle 0,0,(#GameWidth# * #TileSize#), (#GameHeight# * #TileSize#) | FillColor 0,0,0,255 | StrokeWidth 0

[Background]
Meter     = Image
ImageName = #@#Games/#Game#/Resources/Backgrounds/#Background#

[GetObjectLayer1]
Measure = String
String  = #ObjectLayers#
Group   = ObjectLayers
DynamicVariables = 1
RegExpSubstitute = 1
Substitute       = "((.*?)\|){0,0}(.*?)(\||$).*":"\3" 
[ObjectLayer1]
Meter     = Image
Group     = ObjectLayers
ImageName = #@#Games/#Game#/Resources/ObjectLayers/#CurrentScreen#/[GetObjectLayer1]
DynamicVariables = 1


[Player]
Meter = Image
Group = PlayerUpdate
ImageName = #@#Games/#Game#/Resources/Sprites/#PlayerSprite##PlayerDirection#.png
X = (#PlayerX# * #TileSize#)
Y = (#PlayerY# * #TileSize#)
DynamicVariables = 1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Post-Init: Start the main game 'loop'
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
[RUN]
Measure = Calc
OnUpdateAction = [!EnableMeasureGroup NoUpdate]














